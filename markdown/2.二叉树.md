
# 二叉树
## 1.二叉树遍历

两种遍历方式：
1.深度优先：前、中、后序遍历
2.广度优先：层序遍历
DFS用栈，BFS用队列。

### 1.1 DFS
递归遍历略。

#### 先序遍历
迭代：根节点扔栈里。
每次出栈，收集结果。然后将出栈节点的左右节点反着压栈即可。
```swift
class Stack<T> {
    var list:[T] = []
    func push(_ item:T) {
        list.append(item)
    }
    func pop() -> T {
        return list.removeLast()
    }
    func isEmpty() -> Bool {
        return list.isEmpty
    }
    func peak() -> T {
        return list.last!
    }
}

class Solution {
    func preorderTraversal(_ root: TreeNode?) -> [Int] {
        var rs:[Int] = []
        if root == nil {return rs}
        var stack = Stack<TreeNode>()
        stack.push(root!)
        while stack.isEmpty() == false {
            let node = stack.pop()
            rs.append(node.val)
            if node.right != nil { stack.push(node.right!) }
            if node.left != nil { stack.push(node.left!) }
        }
        return rs
    }
}
```
#### 后序遍历
改变先序遍历子节点入栈顺序，可以从中左右，拿到中右左。
中右左，逆序就得到左右中了：

```swift
class Solution {
    func postorderTraversal(_ root: TreeNode?) -> [Int] {
        var rs: [Int] = []
        if root == nil {return rs}
        let stack = Stack<TreeNode>()
        stack.push(root!)
        while stack.isEmpty() == false {
            let node = stack.pop()
            rs.append(node.val)
            if node.left != nil { stack.push(node.left!) }
            if node.right != nil { stack.push(node.right!) }
        }
        return rs.reversed()
    }
}

```

#### 中序遍历
中序遍历比较特殊，遍历的顺序和收集的顺序不一样。需要一个指针维护访问节点
1.拿着一个指针，沿着节点一路left走到底，过程中，非空的left都压栈。（收集左）
2.走到底之后从栈顶pop一个，收集进结果。（收集中）
3.指针指向栈顶对象的right。非空则继续遍历right（收集右）

```swift
func inorderTraversal(_ root: TreeNode?) -> [Int] {
    var rs:[Int] = []
    let stack = Stack<TreeNode>()
    var cur = root
    while !stack.isEmpty() || cur != nil {
        if cur != nil {
            stack.push(cur!)
            cur = cur!.left
        }else {
            cur = stack.pop()
            rs.append(cur!.val)
            cur = cur!.right
        }
    }
    return rs
}
```

### 1.2 BFS
扔队列里，开始时记录下本层长度即可。
```swift
func levelOrder(_ root: TreeNode?) -> [[Int]] {
    var queue:[TreeNode] = []
    var rs: [[Int]] = []
    if root != nil { queue.append(root!) }
    while queue.isEmpty == false {
        let size = queue.count
        var level: [Int] = []
        for i in 0 ..< size {
            let node = queue.removeFirst()
            level.append(node.val)
            if node.left != nil {
                queue.append(node.left!)
            }
            if node.right != nil {
                queue.append(node.right!)
            }
        }
        rs.append(level)
    }
    return rs
}
```
很多题在BSF上稍微改动下即可：

[103.锯齿层序遍历](../mid/102.swift)

[199.二叉树右视图](../mid/199.swift)

[637.层平均值](../easy/637.swift)

### 1.3 基础题的迭代解

只写递归解的题目，补了下迭代解：

[226.反转二叉树](../easy/226.swift)

[100.相同的树](../easy/100.swift)

[101.对称二叉树](../easy/101.swift)

[104.二叉树的最大深](../easy/104.swift)

[111.二叉树的最小深](../easy/111.swift)

